-- 这是一个典型的 Hook 示例（仅在支持此功能的执行器上有效）
local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    -- 拦截 Kick 方法
    if tostring(method) == "Kick" or tostring(method) == "kick" then
        warn("拦截了一次 Kick 尝试: " .. tostring(args[1]))
        return nil -- 返回空，让服务器以为执行成功但实际什么都没发生
    end

    return oldNamecall(self, ...)
end)
setreadonly(mt, true)

-- 反 Kick + Adonis 绕过（无 UI 版）

-- ====== 第一部分：通用反 Kick ======
for _, Value in next, getgc(true) do
    if typeof(Value) == "table" then
        if rawget(Value, "indexInstance")
        or rawget(Value, "newindexInstance")
        or rawget(Value, "newIndexInstance") then
            Value.tvk = {
                "kick",
                function()
                    return task.wait(9e9)
                end
            }
        end
    end
end

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local oldIndex, oldNamecall

oldIndex = hookmetamethod(game, "__index", newcclosure(function(t, k)
    if t == LocalPlayer and type(k) == "string" and k:lower() == "kick" then
        return function(...)
            print("__index 拦截 kick 成功")
        end
    end
    return oldIndex(t, k)
end))

oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    if self == LocalPlayer and getnamecallmethod():lower() == "kick" then
        print("__namecall 拦截 kick 成功")
        return
    end
    return oldNamecall(self, ...)
end))

print("反 Kick 已开启")

-- ====== 第二部分：Adonis AntiCheat 绕过 ======
local getinfo = getinfo or debug.getinfo
local DEBUG = false
local Hooked = {}

local Detected, Kill

setthreadidentity(2)

for _, v in getgc(true) do
    if typeof(v) == "table" then
        local DetectFunc = rawget(v, "Detected")
        local KillFunc = rawget(v, "Kill")

        if typeof(DetectFunc) == "function" and not Detected then
            Detected = DetectFunc

            hookfunction(Detected, function(Action, Info, NoCrash)
                if Action ~= "_" and DEBUG then
                    warn(
                        "Adonis AntiCheat flagged\n" ..
                        "Method: " .. tostring(Action) ..
                        "\nInfo: " .. tostring(Info)
                    )
                end
                return true
            end)

            table.insert(Hooked, Detected)
        end

        if rawget(v, "Variables")
        and rawget(v, "Process")
        and typeof(KillFunc) == "function"
        and not Kill then
            Kill = KillFunc

            hookfunction(Kill, function(Info)
                if DEBUG then
                    warn("Adonis AntiCheat tried to kill: " .. tostring(Info))
                end
            end)

            table.insert(Hooked, Kill)
        end
    end
end

-- ====== debug.info 防检测 ======
local Old
Old = hookfunction(getrenv().debug.info, newcclosure(function(...)
    local LevelOrFunc = ...

    if Detected and LevelOrFunc == Detected then
        if DEBUG then
            warn("zins | adonis bypassed")
        end
        return coroutine.yield(coroutine.running())
    end

    return Old(...)
end))

--!optimize 2

local game, typeof, tostring, pcall, warn, taskwait
    = game, typeof, tostring, pcall, warn, task.wait

local getcallingscript, checkcaller, getnamecallmethod, GetFullName
    = getcallingscript, checkcaller, getnamecallmethod, game.GetFullName

local ExecutorName = identifyexecutor()

local Global  = getgenv()
local Speaker = game:GetService("Players").LocalPlayer

local OldIsHooked, OldIndex, OldNameCall
local OldFunction = clonefunction(Speaker.Kick)

local function GetCalling(CallingScript, ExecutorCall)
    local Calling = CallingScript or ExecutorCall and (`{ExecutorName} LocalScript`)

    if typeof(Calling) == "Instance" then Calling = GetFullName(Calling)
    elseif not Calling then Calling = "Unknown" end

    return Calling
end

local function NewAntiKick(Method, Old)
    return function(self, ...)
        if Global.SafeRJ then return Old(self, ...) end
        if Method == "__namecall" and getnamecallmethod() ~= "Kick" then return Old(self, ...) end

        local Calling = GetCalling(getcallingscript(), checkcaller())
        local Message = not pcall(tostring, ...) and "" or tostring(...)

        warn(`[Anti Kick] Something trying to call 'Player.Kick', calling script: "{Calling}"`)
        warn(`[Anti Kick] Bypassed kick! Kick message: "{Message}"`)
        return (function()
            repeat taskwait(9e9) until nil
        end)()
    end
end

OldNameCall = hookmetamethod(game, "__namecall", function(...)
    return OldNameCall(...)
end)

OldIsHooked = hookfunction(isfunctionhooked, function(Function)
    if Function == Speaker.Kick then return false end
    return OldIsHooked(Function)
end)

hookfunction  (Speaker.Kick,       NewAntiKick("hookfunction", OldFunction))
hookmetamethod(game, "__namecall", NewAntiKick("__namecall",   OldNameCall))

OldIndex = hookmetamethod(game, "__index", function(self, Key)
    if Global.SafeRJ then return OldIndex(self, Key) end
    if self ~= Speaker or Key ~= "Kick" then return OldIndex(self, Key) end

    local Calling = GetCalling(getcallingscript(), checkcaller())

    warn(`[Anti Kick] Something trying to index kick, calling script: "{Calling}"`)
    return OldIndex(self, Key)
end)