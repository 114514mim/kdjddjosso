--[[
WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent
RequestCommand:InvokeServer(";btools me ;fogcolor black")
wait(0.4)
RequestCommand:InvokeServer(";time ;hideguis others")
wait(0.1)
local player = game.Players.LocalPlayer
local char = player.Character
local backpack = player.Backpack

local function getf3x()  
		for _, v in ipairs(backpack:GetChildren()) do  
			if v:FindFirstChild("SyncAPI") then  
				return v  
			end  
		end  
		for _, v in ipairs(char:GetChildren()) do  
			if v:FindFirstChild("SyncAPI") then  
				return v  
			end  
		end  
  
		return nil  
	end  
	local f3x = getf3x()  
	if not f3x then  
		warn("where yo btools at")  
	end  
	local syncapi = f3x.SyncAPI  
	local serverendpoint = syncapi.ServerEndpoint  
  
	local function delete(part)  
		local args = {  
			[1] = "Remove",  
			[2] = {  
				[1] = part  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function deleteall()  
		for _, v in ipairs(workspace:GetChildren()) do  
			if v ~= "Sound" then  
				spawn(function()  
					delete(v)  
				end)  
			end  
		end  
	end  
  
	deleteall()  
  
	local ReplicatedStorage = game:GetService("ReplicatedStorage")  
	local RequestCommand = ReplicatedStorage:WaitForChild("HDAdminHDClient").Signals.RequestCommandSilent  
	local player = game.Players.LocalPlayer  
	local char = player.Character  
	local backpack = player.Backpack  
  
	local function getf3x()  
		for _, v in ipairs(backpack:GetChildren()) do  
			if v:FindFirstChild("SyncAPI") then  
				return v  
			end  
		end  
		for _, v in ipairs(char:GetChildren()) do  
			if v:FindFirstChild("SyncAPI") then  
				return v  
			end  
		end  
  
		return nil  
	end  
	local f3x = getf3x()  
	if not f3x then  
		warn("where yo btools at")  
	end  
	local syncapi = f3x.SyncAPI  
	local serverendpoint = syncapi.ServerEndpoint  
  
	local function resize(part,size,cf)  
		local args = {  
			[1] = "SyncResize",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["CFrame"] = cf,  
					["Size"] = size  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function MovePart(part,cf)  
		local args = {  
			[1] = "SyncMove",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["CFrame"] = cf  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function syncmaterial(part,mate,trans)  
		local args = {  
			[1] = "SyncMaterial",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["Material"] = mate  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
	local function transparency(part,trans)  
		local args = {  
			[1] = "SyncMaterial",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["Transparency"] = trans  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
      
    local function MakeMeshNeon(part)  
    local args = {  
			[1] = "SyncMesh",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["VertexColor"] = vector.create(3, 3, 3)  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function color(part, color)  
		local args = {  
			[1] = "SyncColor",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["Color"] = color,  
					["UnionColoring"] = false  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function syncmeshid(part, id)  
		local args = {  
			[1] = "SyncMesh",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["MeshId"] = "rbxassetid://"..id  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function makemesh(part)  
		local args = {  
			[1] = "CreateMeshes",  
			[2] = {  
				[1] = {  
					["Part"] = part  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function syncmeshsize(part, vectora)  
		local args = {  
			[1] = "SyncMesh",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["Scale"] = vectora  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function syncmeshtexture(part, id)  
		local args = {  
			[1] = "SyncMesh",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["TextureId"] =	"rbxassetid://"..id  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function name(part, stringa)  
		local args = {  
			[1] = "SetName",  
			[2] = {  
				[1] = part  
			},  
			[3] = stringa  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function lock(part, boolean)  
		local args = {  
			[1] = "SetLocked",  
			[2] = {  
				[1] = part  
			},  
			[3] = boolean  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function setcollision(part, booleana)  
		local args = {  
			[1] = "SyncCollision",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["CanCollide"] = booleana  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function setanchor(part, boolean)  
		local args = {  
			[1] = "SyncAnchor",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["Anchored"] = boolean  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
  
	local function createdecal(part, side)  
		local args = {  
			[1] = "CreateTextures",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["Face"] = side,  
					["TextureType"] = "Decal"  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
	local function setdecal(part, asset, side)  
		local args = {  
			[1] = "SyncTexture",  
			[2] = {  
				[1] = {  
					["Part"] = part,  
					["Face"] = side,  
					["TextureType"] = "Decal",  
					["Texture"] = "rbxassetid://".. asset  
				}  
			}  
		}  
		serverendpoint:InvokeServer(unpack(args))  
	end  
      
    local function lockall()  
		for _, v in ipairs(workspace:GetDescendants()) do  
			if v:IsA("BasePart") then  
				spawn(function()  
					lock(v, true)  
				end)  
			end  
		end  
	end  
      
    local function sky()  
		local position = CFrame.new(0, 5, 0)  
		local sky = serverendpoint:InvokeServer("CreatePart", "Normal", position, workspace)  
  
		makemesh(sky)  
		syncmeshid(sky, "111891702759441")  
		syncmeshtexture(sky, "93690633620810")  
        MakeMeshNeon(sky)  
		syncmeshsize(sky, Vector3.new(60001, 60001, 60001))  
		lock(sky, true)  
		name(sky, "the skybox lolz")  
		setcollision(sky, false)  
	end  
  
	local function spawnrealm()  
    local model_id = "79032459095430"

local imported_model = game:GetObjects("rbxassetid://" .. model_id)[1]
imported_model.Parent = game.Lighting

for _, v in next, imported_model:GetDescendants() do
pcall(function()
v.Anchored = true
end)
end

local plr = game:GetService("Players").LocalPlayer
local f3x_name = "Building Tools"
local destination = workspace

coroutine.wrap(function()
task.wait(10)
imported_model.Parent = nil
end)()

function f3xbuildpart(part, cframe, destination, size, transparency, colour, material, collision, fake_part)
local allPartsData = {}

table.insert(allPartsData, {
Type = fake_part:IsA("WedgePart") and "Wedge" or fake_part:IsA("Seat") and "Seat" or fake_part:IsA("VehicleSeat") and "VehicleSeat" or fake_part:IsA("TrussPart") and "Truss" or fake_part:IsA("SpawnLocation") and "Spawn" or
fake_part.Shape == Enum.PartType.Block and "Normal" or
fake_part.Shape == Enum.PartType.Ball and "Ball" or
fake_part.Shape == Enum.PartType.Cylinder and "Cylinder",
CFrame = fake_part.CFrame,
Size = fake_part.Size,
Transparency = fake_part.Transparency,
Color = fake_part.Color,
Material = fake_part.Material,
Collision = fake_part.CanCollide,
Ref = fake_part,
})

local sync = plr.Backpack:FindFirstChild(f3x_name).SyncAPI.ServerEndpoint

local partMap = {}

for _, data in ipairs(allPartsData) do
local created = sync:InvokeServer("CreatePart", data.Type, data.CFrame, destination)
partMap[data.Ref] = created
end

for _, data in ipairs(allPartsData) do
local created = partMap[data.Ref]
if not created then continue end

spawn(function()  
    if data.Size ~= Vector3.new(4,1,2) then  
        sync:InvokeServer("SyncResize", {  
            { Part = created, CFrame = created.CFrame, Size = data.Size }  
        })  
    end  

    if data.Transparency ~= 0 then  
        sync:InvokeServer("SyncMaterial", {  
            { Part = created, Transparency = data.Transparency }  
        })  
    end  

    if data.Color ~= BrickColor.new("Medium stone grey").Color then  
        sync:InvokeServer("SyncColor", {  
            { Part = created, Color = data.Color, UnionColoring = true }  
        })  
    end  

    if data.Material ~= "Plastic" then  
        sync:InvokeServer("SyncMaterial", {  
            { Part = created, Material = data.Material }  
        })  
    end  

    if data.Collision ~= true then  
        sync:InvokeServer("SyncCollision", {  
            { Part = created, CanCollide = data.Collision }  
        })  
    end  

    local ref = data.Ref  

    local texture = ref:FindFirstChildOfClass("Texture")  
    if texture then  
        sync:InvokeServer("CreateTextures", {  
            { Part = created, Face = texture.Face, TextureType = "Texture" }  
        })  
        sync:InvokeServer("SyncTexture", {  
            { Part = created, Face = texture.Face, TextureType = "Texture", StudsPerTileU = texture.StudsPerTileU, StudsPerTileV = texture.StudsPerTileV, Texture = texture.Texture, Transparency = texture.Transparency }  
        })  
    end  

    local decal = ref:FindFirstChildOfClass("Decal")  
    if decal then  
        sync:InvokeServer("CreateTextures", {  
            { Part = created, Face = decal.Face, TextureType = "Decal" }  
        })  
        sync:InvokeServer("SyncTexture", {  
            { Part = created, Face = decal.Face, TextureType = "Decal", Texture = decal.Texture, Transparency = decal.Transparency }  
        })  
    end  

    local mesh = ref:FindFirstChildOfClass("SpecialMesh")  
    if mesh then  
        sync:InvokeServer("CreateMeshes", {  
            { Part = created }  
        })  
        sync:InvokeServer("SyncMesh", {  
            { Part = created, MeshId = mesh.MeshId, TextureId = mesh.TextureId, Scale = mesh.Scale }  
        })  
    end  

    local light1 = ref:FindFirstChildOfClass("SpotLight")  
    if light1 then  
        sync:InvokeServer("CreateLights", {  
            { Part = created, LightType = "SpotLight" }  
        })  
        sync:InvokeServer("SyncLighting", {  
            { Part = created, LightType = "SpotLight", Color = light1.Color, Range = light1.Range, Face = light1.Face, Angle = light1.Angle, Shadows = light1.Shadows }  
        })  
    end  

    local light2 = ref:FindFirstChildOfClass("PointLight")  
    if light2 then  
        sync:InvokeServer("CreateLights", {  
            { Part = created, LightType = "PointLight" }  
        })  
        sync:InvokeServer("SyncLighting", {  
            { Part = created, LightType = "PointLight", Color = light2.Color, Range = light2.Range, Shadows = light2.Shadows }  
        })  
            
       end  
   end)  
end

end

for _, part in next, imported_model:GetDescendants() do
local function spawnpart(fn)
task.spawn(fn)
end
if part:IsA("Part") then
if part.Shape == Enum.PartType.Block then
spawnpart(function()
f3xbuildpart("Normal", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
elseif part.Shape == Enum.PartType.Ball then
spawnpart(function()
f3xbuildpart("Ball", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
elseif part.Shape == Enum.PartType.Cylinder then
spawnpart(function()
f3xbuildpart("Cylinder", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
end
elseif part:IsA("WedgePart") then
spawnpart(function()
f3xbuildpart("Wedge", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
elseif part:IsA("Seat") then
spawnpart(function()
f3xbuildpart("Seat", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
elseif part:IsA("TrussPart") then
spawnpart(function()
f3xbuildpart("Truss", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
elseif part:IsA("VehicleSeat") then
spawnpart(function()
f3xbuildpart("VehicleSeat", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
elseif part:IsA("SpawnLocation") then
spawnpart(function()
f3xbuildpart("Spawn", part.CFrame, destination, part.Size, part.Transparency, part.Color, part.Material, part.CanCollide, part)
end)
end
end

end  
  
  
  
  
  
  
  
  
  
    spawnrealm()  
    sky()  
    lockall()  
  
    wait(2)  
    RequestCommand:InvokeServer(";respawn all")  
    wait(0.8)  
    RequestCommand:InvokeServer(";music 1846575559 ;volume inf")                                                    wait(2)                                                                                             -- 在指定位置生成正常大小转向后方的ifioood人物
local player = game.Players.LocalPlayer
local tool

-- 查找F3X工具
for _, v in player:GetDescendants() do
    if v.Name == "SyncAPI" then tool = v.Parent end
end
if not tool then
    for _, v in game.ReplicatedStorage:GetDescendants() do
        if v.Name == "SyncAPI" then tool = v.Parent end
    end
end

local remote = tool.SyncAPI.ServerEndpoint

function _(args) remote:InvokeServer(unpack(args)) end

-- 核心F3X功能函数
function SetAnchor(part, boolean)
    _({"SyncAnchor", {{["Part"] = part, ["Anchored"] = boolean}}})
end
function CreatePart(cf)
    _({"CreatePart", "Normal", cf, workspace})
end
function Resize(part, size, cf)
    _({"SyncResize", {{["Part"] = part, ["CFrame"] = cf, ["Size"] = size}}})
end
function AddMesh(part)
    _({"CreateMeshes", {{["Part"] = part}}})
end
function SetMesh(part, meshid)
    _({"SyncMesh", {{["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}}})
end
function SetTexture(part, texid)
    _({"SyncMesh", {{["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}}})
end
function MeshResize(part, size)
    _({"SyncMesh", {{["Part"] = part, ["Scale"] = size}}})
end
function SetName(part, stringg)
    _({"SetName", {part}, stringg})
end
function SetCollision(part, boolean)
    _({"SyncCollision", {{["Part"] = part, ["CanCollide"] = boolean}}})
end

-- ==================== 在指定位置生成正常大小转向后方的ifioood人物 ====================
-- 使用指定坐标
local x = -19.80
local y = 379.95
local z = 48.44

-- 创建CFrame：位置 + 转向后方（绕Y轴旋转180度）
local spawnPosition = Vector3.new(x, y, z)
local spawnCFrame = CFrame.new(spawnPosition) * CFrame.Angles(0, math.rad(180), 0)  -- 转向后方

CreatePart(spawnCFrame)

task.wait(0.1)

-- 查找并配置部件
for _, v in workspace:GetDescendants() do
    if v.Name == "Part" and v.Parent == workspace and (v.Position - spawnPosition).Magnitude < 1 then
        -- 设置名称
        SetName(v, "ifioood")
        
        -- 设置为锚定，不会掉落
        SetAnchor(v, true)
        
        -- 添加网格
        AddMesh(v)
        
        -- 使用正常大小（类似Roblox人物大小）
        Resize(v, Vector3.new(2, 6, 1), v.CFrame)  -- 正常人大小（宽2，高6，厚1）
        
        -- 相应调整网格大小，使其看起来像正常人
        MeshResize(v, Vector3.new(0.04, 0.04, 0.04))  -- 正常大小缩放
        
        -- 设置网格和贴图
        SetMesh(v, "1347582902")
        SetTexture(v, "136244369348699")
        
        -- 设置为有碰撞
        SetCollision(v, true)
        
        -- 设置方向：转向后方（已通过CFrame设置）
        v.Orientation = Vector3.new(0, 180, 0)  -- Y轴旋转180度，面向后方
        
        -- 可选声音效果
        local sound = Instance.new("Sound", v)
        sound.SoundId = "rbxassetid://153752123"
        sound.Volume = 0
        sound.PlayOnRemove = true
        sound:Destroy()
        
        print("✅ 正常大小ifioood已生成在指定位置并转向后方")
        print("  位置：X: " .. x .. " Y: " .. y .. " Z: " .. z)
        print("  尺寸：2x6x1（正常人大小）")
        print("  网格缩放：0.04倍")
        print("  方向：面向后方（Y轴180度）")
        print("  已锚定：不会掉落")
        print("  有碰撞：可以交互")
        break
    end
end